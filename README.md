# simple-compiler

注：代码文件中我添加了大量中文注释，以帮助理解，测试用例文件在test-cases文件夹里，可以在主类中通过调整测试文件的文件名，相应的结果会在控制台上输出出来，如有问题或建议，欢迎邮箱联系本人：caoy_man@163.com 

简单的前端编译器，编译解析一种特殊的，有着严格且死板格式限制的编程语言

下面为相应的实验报告和存在的缺陷

实验报告代码说明
实验内容：
设计构造四元分析式：
		目标：在前面词法分析器和语法分析器的基础上，按照四元式构造的规则去构造一段分程序正确的四元式，以实现程序的正确执行。
功能要求：对于一段给定的不含函数调用语句（例如：call F(F为函数名称)）的分程序，实现四元分析式的构建。而所谓的四元分析式，实际上就是程序的一种执行顺序， 每个四元分析式含有五个部分，分别是①前面的位序：代表这是第几个四元式（从1开始）；②参与运算的运算符：可能为跳转标记“j”（为假跳转），或是标记为“j比较运算符”（例如：j<），或是算数运算符（+、-、*、/），或是赋值运算符；③第一个运算数：有时候是以“T”打头的中间变量，或是一些变量（定义过的和没有定义过的），和常数，当该四元式为假跳转时，此处的值为空格“ ”；④第二个运算数：在包含第一个运算数所说的几种取值的情况下，当运算符为赋值运算符时，取值为“ ”；⑤目标数：当四元式为跳转语句时，目标数为某个四元式的位序，而当四元式为某个赋值语句或运算语句时，目标数为某个以“T”打头的某个中间变量或是某个变量（定义过的和没有定义过的）。覆盖的程序语句类别包括：含有+-*/运算的赋值语句、if条件语句和while条件语句，以及可含有上述三种语句类型的复合语句。
注：没有定义过的变量也会加入四元式分析，但会在四元式分析之后给出相应的错误提示信息和错误位置。这些给出的错误都属于同一个类型——使用的变量未定义。
参与人员：个人
一、	实验平台：
运行环境: Visual Studio2019
操作系统：win10操作系统
二、	程序构架：
 
三、	各类具体设计及遇到问题
前提：四元式的构建通过一个名为Quaternion的类来实现，并以词
1.	如将语法分析类（Grammar_analyzer类）的结果与四元式构建类（Quaternion类）联系起来？
答：首先我们要明确，四元式的构建要干什么，要进行变量定义检查，还要对上述的语句进行四元分析，因此在语法分析过程中，将所有的定义的变量都存储在一个set容器中（作为一个private变量），而将用于分析的表达式都放到一个vector容器中，要想在Quaternion类中使用这个结果，我们可以在Quaternion类中定义一个带语法分析器类（Grammar_analyzer类）对象的构造函数，并用智能指针联系起两个类，这样既省时间，又能达到目的。
2.	每个程序由多个四元式构成，而对于每个四元式，又包括五个属性，如何对每个四元式的这五大属性进行有效管理？
答：定义一个名为FourElements的struct（结构体），包含五大属性：
oper（对应的运算符或含有跳转标记“j”），var1（第一个运算数），var2（第二个运算数），aim（目标变量或目标四元式位序），num（该四元式对应的位序，从1开始）以及配套的构造函数和拷贝构造成员（析构函数使用的是默认的合成的析构函数，没有加什么收尾处理）。由此就可以定义一个FourElements类的对象对每个四元式的五大属性进行有效管理。
3.	对于四元式构建类（Quaternion类）的结果如何进行存储？
答：⑴对于每个因为使用未定义变量的错误，存储在一个vector<pair<size_t, string> >的名为error的vector容器中，pair对象的first成员为错误对应的位置，string为错误未定义变量的名字。
⑵对于每个四元式的存储，存储在一个vector<FourElements>类的名为fe的vector容器中。
⑶补充：对于语法分析给出的结果：已经定义的变量记录由类型为shared_ptr<set<string> >名为define的智能指针与语法分析器类对象的对应容器联系起来；而要处理的各种表达式由类型为shared_ptr<vector<pair<size_t, vector<pair<size_t, string > > > > >类型的名为expr的智能指针与语法分析器类对象的对应容器联系起来。
4.	expr中地内容具体是怎么样的？或者说以何种形式？
答：expr的含义是表达式，也就是说主要是为了存储用于构造四元式的表达式而设立的，但是为了实现四元式之间的正确跳转，除了表达式，我们还加入了一些别的东西来标记条件语句或while循环语句的开始或结束。
具体来说的话：
① 对于if或while语句的条件表达式：我们会将“if”或“while”放到表达式开始处，然后接着会有具体的没有左右括号围着的条件表达式，例：
if/while a + b < b * (3 + 4 / r) && c > d || a < k 。

② 对于if-else中含有else的情况，我们会将单独的一个else作为一个表达式语句放到容器中，以标记实现相关的明确当前构造的四元式是处于什么语句的状态。
例如：if a > b
		c = d * 8 + m
 else (单独作为一个表达式放入相应的expr中)
 k = g

③ 对于包含有复合语句的情况，我们将begin和end单独作为一个表达式语句放到expr的一个表达式语句中，以此作为复合语句的结束和开始。
例如：
if a < b
begin
a = 3
end
else 
begin 
a = 4
end
注：如果还是不理解这个expr的存储的东西的形式，可以运行程序，程序中有输出，比对后即可明白相关原则。

5.	四元式是为了教会计算机根据规定的顺序来执行语句，其中必然涉及到很多的运算符的顺序，我们首先明确涉及到哪些运算符，以及这些运算符的优先级比较是怎么样的？
答：⑴涉及到的运算符：
算数运算符（+、-、*、/），比较运算符（>、<、>=、<=、<>、!=），逻辑运算符（&&、||）（识别不了“and”，“or”，不会报其语法错误，但本质上并不是将其当作逻辑运算符的故不能产生正确的四元式），赋值运算符（=,+=,-=,*=,/=,%=,>>=,<<=,&=,|=,^=）、左右括号（“(”，“ )”）

⑵运算符间的顺序：从大到小排列
左右括号（“(”，“ )”）> 算数运算符（* = / > + = -）> 比较运算符（>、<、>=、<=、<>、!=）（比较运算符之间平级）> 逻辑运算符（&& > ||） > 
赋值运算符（=,+=,-=,*=,/=,%=,>>=,<<=,&=,|=,^=）（赋值运算符之间平级）
注：以上红色>、=为运算符之间的优先级比较符号。
6.	在四元式构建的过程中，我们发现，一定要根据正确的运算顺序产生在在正确的位置产生正确的四元式，那么如何实现一个复杂表达式的正确的运算顺序呢？
答：用两个栈，一个放运算符的栈（类型为stack<pair<size_t, string> >的名为op的运算符栈），其中pair对象的first成员为运算符对应的种别码，而second成员为对应运算符的具体的值（即具体是什么运算符）；另一个栈是放运算数的栈（类型为stack<string>的名为name的标识符栈），其中的string类型的成员即为每个运算数的具体的值，可能为一个常数，或者是一个标识符（不是关键字啊！）。
		对于以上的两个栈，我们按照如下规则进行操作，对于我们要进行四元式构建的语句，我们将存储其的地方到了用智能指针expr将其联系，要明白，所有语句放到了一个大vector中，而每条语句最终是放到一个小vector中的（vector中的vector），vector的每个元素就是每个单词，故这么做我们可以对每个单词进行提取和操作。扫描每条语句的单词（单词可能是常数、标识符或是运算符或是其他一些重要标记（if、else、while、begin、end等）），而我们目前不考虑单词是某种标记的情况，如果这个单词是常数或标识符，无条件进入标识符栈name，并且如这个单词是个标识符，要对智能指针define调用find函数看看这个标识符有无被提前定义，未定义要记录错误信息。而如果是运算符，如果运算符栈op为空，则无条件入栈，如果读到的运算符是左括号，则无条件入栈，如果，读到的是右括号，则将op栈中的内容依次弹出，同时连续弹出两个name栈中的内容进行处理，处理完后如果不是关于赋值运算符的处理，需要将产生的中间结果放到name栈中，重复这个过程直到遇到了有一个左为止，然后将左括号弹出op栈如果是其他运算符，就要根据上述的优先级来确保op栈顶的优先级必须最高，如果当前读到的运算符的优先级小于等于栈顶的运算符的优先级，则连续弹出op栈栈顶运算符并根据类似于上述左右括号运算符的处理办法对每个运算符进行处理，直到留下的op栈栈顶的运算符优先级小于当前运算符或当前op栈为空的时候，再将当前运算符入栈。在这个过程中再辅助以四元式的构建，由此实现四元式按照规定的顺序构建执行。
注：逻辑运算符并不入栈，它们的主要作用是控制跳转类型的四元式，对于其具体操作我们将在后面的某些问题的解决策略中做具体说明。
7.	如何实现四元式的位序从1开始依次排列？
答：有两种思路，第一种是在四元式的结构体FourElements中设置一个静态变量叫做order，初始值为1，然后每创建一个四元式就对其进行加1操作，由此来实现位序从1依次排列，但是这么做有个缺陷，就是如果当我涉及的过程中用到了某些需要临时设置FourElements对象的时候就涉及到一个使用完其离开自己的作用域会删除的问题，即会发生序号断层，如果再对其进行调整的话会很麻烦，因此我没有那么做，我是采用了第二种策略：使用了一个类型为size_t名为order的变量，每往最终的四元式记录容器fe中插入一个元素，对应的order加1并赋值给FourElements的num成员，由此实现四元式的位序从1开始依次排列。而类似地，对于以字母“T”打头的中间变量的值，我也采用了类似的方法，设置了一个类型为size_t名为tmp_order的变量，每当需要到一个新的中间，tmp_order值加1，以实现中间变量位序的依次递增。
8.	如何实现四元式之间的正确跳转？
答：四元式的灵魂，不仅在于其能给出正确的表达式的运算顺序，还在于其可以实现通过跳转实现整个程序的正确执行，从而满足我们在各种功能逻辑上的要求，但是怎么样才能保证跳转的目标正确呢？这些需要跳转的四元式彼此并不相邻（相邻也不需要跳转），这似乎很难实现。我们发现，先不管跳转的目标是什么，跳转语句的出现总是非常有规律的，即：跳转语句总是与条件表达式有关，那么我们就要首先对条件表达式进行剖析研究了
条件表达式主要由比较表达式和逻辑运算符（“与”运算符&&、“或”运算符||）构成，其一定跟在if或while语句后，else语句后没有条件表达式，赋值语句中没有条件表达式（虽然C++的文法可以这么干，但是我们毕竟要简化情况）。而比较表达式主要由比较运算符（>、<、==、>=、<=、<>、!=）和比较运算符左右两边的表达式构成，其中这个表达式中的运算符只包含左右括号和加减乘除。
我们发现，对于每个比较表达式，其一定生成两个四元式：为真跳转四元式、为假跳转四元式。为真跳转四元式的运算符一定是以“j”打头，后面跟着对应的比较运算符；为假跳转四元式的运算符一定是“j” ，运算数var1、var2的值都不为空；运算数var1、var2的值都为空，共同的特点是最终的目标都是表示某个四元式的位序的数。所以，既然生成的四元式的数目和位置是固定的，甚至于四元式中除了表示跳转目的的aim暂时不确定外其他的属性都可以随着读到这个表达式确定下来，那么我们不妨先把这些四元式在fe中的位置给留出来，到“适当的”时候再对相应的aim值进行调整（adjust），而不是到恰当的时候把相应的跳转语句插入到fe中，因为顺序结构插入元素很浪费时间，我们提前留好位置，到时候只需要调整对应的aim值就好了。那么，该怎么实现调整？调整为何值？在何时实现调整？针对不同的情况，我们先借助明确各种跳转原则。
跳转原则如下：
① “与”、“或”运算符的本质是控制为真、为假跳转，我们来总结一下其各自的跳转特征，对于“与”运算符（&&）：为真跳转是跳转到其后面的第二个四元式（下一个比较表达式的开始的四元式）（因为为真跳转的后面紧跟着为假跳转），而其为假跳转就不确定了，因为对于if、while语句来说（逻辑运算符一定出现在条件表达式中），为假跳转表明不满足该条件，此时要注意，如果在该条件表达式中这个“&&”运算符的后面还有一个“||”，则我们跳转到这个“||”运算符紧挨其后的第一个表达式对应的第一个四元式。而如果这个“&&”运算符的后面找不到“||”，则说明不执行对应的if或while语句体中的内容，这时就应该跳到它们语句体的外面去，因此此时为假跳转的目标暂时不能确定。对于“或”运算符（||）：其为真跳转是跳到语句体的最开始的四元式处，也就是条件表达式结束的四元式的下一个四元式，所以这个跳转的目的暂时不能确定，只有扫描完该条件表达式语句才可以确定，而对于其为假跳转，则是跳到下一个比较表达式的开始的四元式（其后第二个四元式），这个可以确定。
②而对于那些比较表达式后面没有逻辑运算符的比较表达式（比如：if(a<b)、while(a>3+4*(c-d))……），如果不符合，其为真跳转则是跳转到紧挨其后面的第二个四元式（紧挨其后的第一个四元式为为假跳转），其为假跳转需要跨过整个语句体。
③对于if-else这种结构的条件语句，我们需要明确的一点是，当程序执行完if语句体中的内容时，其不再执行else中的内容，因此此时需要一个语句跳转以跨过else语句体的内容。
④对于while循环语句，为了实现循环，在其语句体中的内容执行完以后，应当重新跳转到条件判断处。

我们现在想一想，跳转语句的调整的难点在哪里，就是对于跨越整个语句体的跳转，重要的是明确要调整哪个语句的aim，因此要记录对应的FourElements元素在fe中的位序；还有就是要明确对应的语句体何时结束，比如有可能语句体中只有一个赋值语句，或是有可能由一个复合语句构成（begin和end之间夹着多个语句），但是也有可能是另一个if或while条件表达式（即为嵌套结构），针对这三种不同的结束方式，我们引入一个新的概念叫“结束方式”，下面介绍三种结束方式：
① sem_end：表明语句体中只有一个语句，形式如：if(a<b)a=b*2(3+c);或while(c>b)a+=b。sem_end的含义是以分号结尾。
② end_end：表明语句体中是一个begin-end之间的复合语句。形式如：if(a<b)                       while(b>c) 
begin                          begin 
a=c;                            c=a+b*(d-c); 
end                             m=k; 
                               end
end_end的含义是以end结尾。
③ wait_end：表明语句如果是嵌套结构，暂时不能确定其结束标记，形式如：if(a<b)        while(a>c)       if(a<b)       while(a<m)
     if(c>d)         while(c<e)      while(c>a)     if(n>k)
     ……            …….          …….         ……
但是最后总会有一个结束落点的，或以分号结尾、或以end结尾。

注：而由于if、else、while语句的相关跳转还是有一点区别的，所以分别在sem_end、end_end、wait_end前面加上if_、else_或wh_分别表示if语句、else语句、while语句的不同的结束情况，基于此，定义了一个枚举类型的变量。如：
enum end_way {
		if_sem_end, if_end_end, if_wait_end,
		else_sem_end, else_end_end, else_wait_end,
		wh_sem_end, wh_end_end, wh_wait_end  };
由此来表示每种不同的结束方式。

为了实现正确的跳转调整所设置的各种数据结构（主要是栈，但是栈中放置地元素种类各有不同）：
① stack<end_way>which_end;//哪种结尾方式的栈，当检测到条件语句的标记if或while时，认定当前检测的是一个条件表达式，这个时候，我们为了明确条件语句或while循环语句的语句体的结束标记是什么，需要再往前探索一位，依据其条件表达式后面跟着的是什么标记来明确当前if或while语句的结束标记是什么，并将对应的结束标记放到which_end中。

② stack<pair<size_t, end_way> >adjust_aim_end;//等待调整的跳转语句的在fe中的位序和结束方式的集合，此种跳转属于跳转到所要执行的的语句体结束之后的下一条四元式语句（跨过整个语句体的跳转）
③ stack<size_t>aim_end_order;//上述每个需要调整的语句对应的四元式跳转位于的语句在expr中的位置。为了保证当条件表达式中的“与”
	//运算符前面的那个比较表达式跳转正确，即如果这个条件表达式中有“||”，只对于位于同一个条件表达式的比较表达式的四元式之间进行跳转，因为根据设计的方法，会产生不同条件表达式语句之间的错误跳转，我必须将其局限在一个条件表达式中。
④ stack<size_t>adjust_or_aim;//等待调整的跳转语句的在fe中的位序的集合，针对的是遇到逻辑运算符“或”的情况，因为当或前面的表达式正确时，直接跳转到语句体开始的四元式处执行，即为条件表达式的四元式结束之后，这时对对应的进行调整。
⑤ stack<pair<size_t, end_way> >adjust_and_aim;//等待调整的跳转语句的在fe中的位序的集合，针对的是遇到逻辑运算符“与”的情况，因为当或前面的表达式错误时，直接跳转到后面所遇到的第一个“或”运算符的后面的第一个四元式，如果其后面没有或运算符，则跳转到语句的结束

⑥ stack<pair<size_t, end_way> >wh_start_aim;//用于存储while语句的最开始语句代表的四元式的位序的栈，pair的first对象即为while语句的最开始语句代表的四元式的位序，而second成员存储while语句体的结束方式标记，由此来实现while语句体中的内容执行完以后通过一个跳转语句实现循环。

⑦ stack<bool >bg;//如果这个begin是紧跟在if、else或者是while后面的，则入栈为true，反之则为else，为了解决多个复合语句嵌套时产生的begin-end匹配错误。因为对于复杂的程序书写情况，如果这个end对应的begin不是紧挨在if或while条件表达式后，那么这个end就不必要进行相应的if、while条件表达式中产生的四元式的跳转语句的调整，由此可以应对多个begin-end复合语句嵌套的内容，实现正确的begin-end匹配以实现正确的跳转。
 
⑧ stack<pair<size_t, end_way> >adjust_and_or_aim;//pair对象的first成员存储的是四元式位于fe中的位序，second成员是结束方式，专门用于当前的条件语句（如果是条件语句就能派上用场，否则不行），如果“与”运算符后还跟着“或”运算符，则进行相应跳转语句的调整，相当于给程序调bug时的一个产物吧，它只临时存在于对于expr中的每个表达式分析的时候，辅助adjust_and_aim工作，就是如果当前的条件表达式的这个“&&”后面又“||”，就操作adjust_and_or_aim，如果adjust_and_or_aim出栈，则adjust_and_aim出栈。而如果没有“||”，则操作adjust_and_aim，不管adjust_and_or_aim。

注：以上的各种数据结构的功能讲解就是这样了，因为这个代码的体量比较大，程序书写的格式比较复杂，尤其是对于诸多嵌套情况的处理，不经过大量的调试很难预先设计，思路有些难以厘清，而且好多解决策略就是灵光一现，没有做及时清楚的记录，所以某些功能的表述不太清楚或和实际功效有出入，一切均已实际为准，如有不清楚敬请谅解。
四、	功能测试
测试数据说明：因为上次语法分析并没有完全按照给定的要求进行，所以我的每条语句，不管语句的后面是不是end或end.，每个赋值语句或定义变量语句都以分号“;”结尾。而且我们的四元式构造针对的是正确的程序，错误的程序会构造出毫无头绪的四元分析式。
功能测试部分：
测试数据1：
① 测试代码：所给的测试样例：
procedure a begin
def a,b,c;
	a=1;
	b=2;
	c=1+2*3+(4+5)*6;

	if (a+b<c)
	begin
		a=a+b;
		b=b+a;
	end
	else
		c=1000;

	while (c>500 && c<2000 && c<>12 || c>4)
	begin
		if (a>3)
			c = c+500;
		if (c<4)
			if (a>b || c<1)
				a=1;
	end
end.








运行结果截图：
 

 



测试数据2：
测试的代码：
procedure d begin
def a,b,c,d,e,f,g,h,i,j,k;

a=a+c*(k-h*i)/5;

while(a>=c)
begin
while(a<b && d + e - f * k>j || j>=h)
begin
c=d*i+j-(5+k-a*b)-c;
end
end
end.
运行结果截图：
 
 

测试数据3：
测试代码：
procedure a begin

def a,b,c;
//a=3.1415926;
if(a<b&& a>c + b+5+6+7+8)
a=1;
else
b=2;

while(a<b && a< c&& b<c || a>c)
begin
if(a<c && a+2*(4+5)/6>= b)
begin
a=c+c+b*2;
b=1e+3;
end
else
begin
a=a+567;
end
end

end.
运行结果截图：
 

 

测试数据4：
测试代码：
procedure a begin

def a,b;

while(a<b)
begin
a=1;
a+= b;
b*=a;
a/=b;
end

if(a<1)
a=b;
else
begin
a=3;
b+=a;
begin
b=4;
end
end


end.
运行结果截图：
 
测试数据5：
测试代码：
procedure a begin
def a,c,b;

if(a<b || b>c+a)
begin
a=c;
a=c+b*a;
end

//c*=b;
else
begin
a*=b;
end

//c=a+b;

end.
测试结果截图：
 


测试数据6：
测试代码：
procedure a begin

def a,b,c,d;
begin
if(a<b)
if(a<c)
begin
if(b<c)
a+=c;
else
a+=b;
end
end
k=1;
end.
测试结果截图：
 


测试数据7：
测试代码：
procedure a begin

def a,b,c,d,p,df;

if(a<b)
c=df;
begin

if(a+b*3.14*(c-d+df)/2.0 < 5 || c - d>=d +df)
begin
p-=df;
a+=c;
end

else
begin
c=1e;
d=3*c;
end

d=c*12.3+6/(5.0-3);
end

end.
测试结果截图：
 

 


测试数据8：
测试代码：
procedure e begin

def a,b,c,k,m;

if(a<b)
begin

begin
if(a<c)
if(a>=b)
if(b>c)
a*=c; 

a-=b;

end

a=3;
end


else
begin
a=c;
c=b;
c+=a;
end

b+=c;

end.
测试结果截图：
 
注：以上测试结果均符合预期。
五、	程序存在不足：
缺陷1：对于if-else的嵌套机制并不完善，当书写如下形式：
	while(a>b)
		if(c>d)
		expr;
		else
		expr；
时，程序不能构造出足够正确的四元式，因为本程序在实现语句跳转的时候采用的原则是找到不同语句对应的正确的结束标记，对于外层的结构，其结束标记依赖于内层。
而出错的原因是while语句错把if语句体的结束标记当成了结束标记。如果将其写作如下形式即可构造正确：
	while(a>b)
	begin
		if(c>d)
		expr;
		else
		expr；
	end
而如果将上述的外层结构由while换成else也会有一样的问题，其解决方式也是一样的。

缺陷2：当多个while和if混合嵌套时，比如如下形式：
while(a<b && b>c)
while(a<d)
if(a>c)
while(c>d)
while(m>=n*90-(6+d))
a*=c;
的形式时，即while在if的上面直接嵌套（没有加begin和end复合标记将二者隔开），则这个时候会产生相应跳转语句的跳转目标错误，这是由于内在设置机制出错造成的，通过修改代码应该可以消除这个错误，但是
比较复杂，故这里通过采用规范程序的书写形式来作出纠正，当出现多个while、if语句嵌套时，最好用begin-else复合语句将其隔开，其本质上是if与while不能遇到同一个落点语句（赋值语句），否则就会产生跳转
的错误，所以我们可以将上述的程序修改为：
while(a<b && b>c)
while(a<d)
if(a>c)
begin
while(c>d)
while(m>=n*90-(6+d))
a*=c;
end
时可以避免错误，而对于程序：
while(a<b)
while(c>d)
if(c<=d)
while(a>=b)
while(e>=f)
if(m>=n)
while(k>m)
while(k>3)
a=8*(m+n)/3-2;
可以修改为：	while(a<b)			和		while(a<b)	都可以。这就是对于上面的论述的实际操作。
		while(c>d)					while(c>d)
		if(c<=d)						if(c<=d)
		begin						while(a>=b)
		while(a>=b)					while(e>=f)
		while(e>=f)					if(m>=n)
		if(m>=n)						begin
		begin						while(k>m)
		while(k>m)					while(k>3)		
		while(k>3)					a=8*(m+n)/3-2;					
		a=8*(m+n)/3-2;					end
		end
		end
。。。。。。又经过一些测试，好吧我也混乱了，总之就是当遇到if和while混合嵌套的过程中，要用复合语句的begin-end将它们隔开。

缺陷3：
两个分程序的四元式分析必须分开，不然就会连在一起分析，从而产生荒谬的跳转错误。
